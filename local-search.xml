<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>《SSA Book》- 5. SSA的高级构造算法</title>
    <link href="/2022/04/23/ssa-book-5/"/>
    <url>/2022/04/23/ssa-book-5/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="ssa-book--5.-ssa的高级构造算法">《SSA Book》- 5.SSA的高级构造算法</h1><p>在“3.SSA的基本构造算法”中，介绍了构造SSA的基本方法。Φ语句将会被插入至变量定义的支配边界位置，该Φ语句本身也将变成新的定义。本文将会给出关于求解支配边界DF<sup>+</sup>集合的高级算法，包括：</p><ol type="1"><li>基于DJ-grpah构造DF<sup>+</sup>集合的方法；</li><li>基于数据流分析的DF<sup>+</sup>集合构造方法；</li><li>基于Loop Nesting Forest的DF<sup>+</sup>集合构造方法。</li></ol><h2 id="使用dj-grpah构造dfs">使用DJ-grpah构造DF<sup>+</sup>(S)</h2><h3 id="算法原理">算法原理</h3><p>在支配树上加上原有控制流图中剩余的边，即可构成DJ-graph，这些加上去剩余的边即为joinedge（J-edge）。下图给出一个例子，可以发现，所有的J-edge出发点所在层数永远不会大于目标点。我们可以假设存在一个J-edge从8→7，那么则存在路径从3→8→7，那么6将不再支配7，这和现有的支配树是互相矛盾的。</p><figure><imgsrc="https://gqrelic-blog-data.oss-cn-shanghai.aliyuncs.com/ssa-book-5-2022-04-23-13-52-37.png"alt="DJ-graph的例子" /><figcaption aria-hidden="true">DJ-graph的例子</figcaption></figure><p>对于DJ-graph中的两个节点w和x，若w是x的祖先节点，那么w的支配边界集合DF(w)满足下列公式：</p><p><span class="math display">\[\begin{split}    DF(w) = &amp;\{z|z \in DF(x) \land z.depth \le w.depth \} \cup \\    &amp;\{z&#39;|y \in subtree(w)/subtree(x) \landy\stackrel{J}{\rightarrow}z&#39; \land z&#39;.depth \le w.depth \}\end{split}\]</span></p><p>文字解释上述公式，DF(w)由两个部分组成，一部分是DF(x)中深度不大于w的节点，另一部分是w的子树中不属于x子树部分的节点y的J-edge，且目标的深度不大于w。</p><!-- TODO：为什么这样就成立呢？ --><blockquote><p>TODO：不太理解为什么全部都存在“深度不大于w”的要求呢？</p></blockquote><p>我们以计算DF(3)和DF(8)为例。在简单的构造方法中计算DF(3)时，我们需要遍历所有3支配的节点{3,4,5,6,7,8,9,10}，判断这些节点存不存在不被3所支配的后继，最终得到DF(3)={2}。接着同样的方法将会应用至DF(8)的求解过程。然而，在利用上述公式后，我们可以先计算DF(8)的值，接着直接利用DF(8)的结果，并遍历{3,4,5,6,7}，即可得到DF(3)。这样子有效减少了冗余运算。</p><p>在求解DF<sup>+</sup>(S)的过程中，需要迭代的进行大量节点的DF计算。将上面的公式运用到算法，一次遍历节点便可求解得到DF<sup>+</sup>(S)，避免计算计算DF之间的冗余操作。</p><h3 id="算法实现">算法实现</h3><p>算法在求解DF<sup>+</sup>(S)时，将所有的节点存放至一个“OrderedBucket”顺序桶中。顺序桶可以理解为一个具有N个槽的数组，N为支配树的高度，每个槽存放一个链表的开头，链表上连接了位于这个深度的节点。接着，对于桶中深度最深的点，执行Visit(x)算法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">for</span> S中的每一个节点x &#123;<br>    InsertNode(x);<br>    x.visited = <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">while</span> x = 桶中最深节点 &#123;<br>    curr_x = x;<br>    x.visited = <span class="hljs-literal">true</span>;<br>    Visit(x)<br>&#125;<br></code></pre></td></tr></table></figure><p>Visit()算法如下所示，对于每个节点的J-edge边使用传统的DF(x)计算方法，并把不在S中的节点存放到桶中；对于D-edge采用递归的方法，直接获取支配边目标节点的运算结果。</p><figure><imgsrc="https://gqrelic-blog-data.oss-cn-shanghai.aliyuncs.com/ssa-book-5-2022-04-23-16-00-22.png"alt="过程：Visit(y)" /><figcaption aria-hidden="true">过程：Visit(y)</figcaption></figure><p>下图反映了计算之前控制流图中DF<sup>+</sup>({1,3,4,7})的过程：</p><ol type="1"><li>首先，最深节点的支配边界DF(7)={2}，2被插入到DF<sup>+</sup>中，也被插入至桶中；</li><li>计算节点4，首先J-edge指向的基本块5被插入到DF<sup>+</sup>和桶中；</li><li>类似的分析将会被应用于5和6，这三个节点均不存在D-edge，因此只会添加J-edge至结果中。进行完上述过程之后，DF<sup>+</sup>({1,3,4,7})={2,5,6}，为如图中最右侧的状态；</li><li>接着，需要分析当前最深节点3，节点3的D-edge中只有基本块8没有被visited，因此调用Visit(8)；</li><li>8，9，10均不存在深度低于3的J-edge，因此遍历节点8以及8的子树，并没有新节点加入DF<sup>+</sup>之中；</li><li>最终，遍历节点2和1时，不存在J-edge和没有visit的D-edge，遍历结束。结果为DF<sup>+</sup>({1,3,4,7})={2,5,6}</li></ol><figure><imgsrc="https://gqrelic-blog-data.oss-cn-shanghai.aliyuncs.com/ssa-book-5-2022-04-24-12-51-42.png"alt="使用算法计算DF+({1,3,4,7})的过程" /><figcaptionaria-hidden="true">使用算法计算DF<sup>+</sup>({1,3,4,7})的过程</figcaption></figure><h2 id="使用数据流计算构造dfs">使用数据流计算构造DF<sup>+</sup>(S)</h2><p>数据流分析的几个关键元素如下所示：</p><ol type="1"><li>初始化：对DJ图中的每一个节点x，初始化DF<sup>+</sup>(x)={}；</li><li>遍历方法：前向遍历，基于BFS从根节点开始遍历；</li><li>数据流传递公式：对于J-edge y→z，那么对于所有满足“x domy且x.depth≥z.depth”节点x，满足：<spanclass="math inline">\(DF^+(x)=DF^+(x)\cup DF^+(z)\cup\{z\}\)</span>；</li><li>不一致条件（即需要继续数据流分析的条件）：对于J-edgey→z，y不满足<span class="math inline">\(DF^+(z) \subsetDF^+(y)\)</span>，则y为不一致的。</li></ol><p>基于上述这些条件，可以得到数据流分析算法。外部函数重复调用该函数，直到该函数返回值为false时停止。结果将会得到每一个节点x的DF<sup>+</sup>(x)集合。</p><figure><imgsrc="https://gqrelic-blog-data.oss-cn-shanghai.aliyuncs.com/ssa-book-5-2022-04-24-12-15-24.png"alt="数据流分析的DF+构造方法" /><figcaptionaria-hidden="true">数据流分析的DF<sup>+</sup>构造方法</figcaption></figure><p>同样以之前给出的数据流图为例，接下来对算法执行过程进行介绍。</p><ol type="1"><li>当从顶部开始遍历时，碰到的第一个J-edge为7→2，这使得DF<sup>+</sup>(7)，DF<sup>+</sup>(6)，DF<sup>+</sup>(3)，DF<sup>+</sup>(2)全部更新为{2}。更新完毕后检查<spanclass="math inline">\(DF^+(2) \subset DF^+(7)\)</span>，发现满足；</li><li>接下来可能被遍历到的J-edge有5条，假设从5→6开始，则更新<spanclass="math inline">\(DF^+(5)=DF^+(5)\cup DF^+(6)\cup\{6\}={2,6}\)</span>，且<span class="math inline">\(DF^+(6) \subsetDF^+(5)\)</span>成立；</li><li>接着是剩下的边，同样按这个方式进行遍历，其中遍历6→5时，会出现不一致条件，这样就需要在本次遍历完毕之后，再进行一次遍历。最后就可以得到所有点的DF<sup>+</sup>集合。</li></ol><figure><imgsrc="https://gqrelic-blog-data.oss-cn-shanghai.aliyuncs.com/ssa-book-5-2022-04-23-13-52-37.png"alt="DJ-graph的例子" /><figcaption aria-hidden="true">DJ-graph的例子</figcaption></figure><p>当得到了单个节点x的DF<sup>+</sup>集合后，那么集合S的DF<sup>+</sup>(S)即为S中所有元素x的DF<sup>+</sup>(x)的并集。</p><h2 id="基于loop-nesting-forest的df集合构造方法">基于Loop NestingForest的DF<sup>+</sup>集合构造方法</h2><h3 id="在无环图下的df构造算法">在无环图下的DF<sup>+</sup>构造算法</h3><p>首先，在控制流图中存在循环结构，如果在CFG的深度优先生成树中有一条指向其祖先的边m→n，则m和n之间的子图构成了一个循环，且n被称为循环头。如果所有循环只有一个入口，那么这个控制流图被称为可规约的。下图中图(a)为可规约的，图(b)为不可规约的。</p><figure><imgsrc="https://gqrelic-blog-data.oss-cn-shanghai.aliyuncs.com/ssa-book-5-2022-04-23-22-46-49.png"alt="可规约循环和不可规约循环" /><figcaption aria-hidden="true">可规约循环和不可规约循环</figcaption></figure><p>对于可规约图，我们可以将所有的循环部分转换成一个节点，并将循环头和循环内部节点提取出来，构成循环森林（LoopNesting Forest）。下图展示了一个例子：</p><figure><imgsrc="https://gqrelic-blog-data.oss-cn-shanghai.aliyuncs.com/ssa-book-5-2022-04-23-22-52-11.png"alt="控制流图及其循环森林示例" /><figcaption aria-hidden="true">控制流图及其循环森林示例</figcaption></figure><p>使用循环森林的目的是：如果一个循环包含一个def，那么它的循环头也属于DF<sup>+</sup>。此外，当控制流图中两个不同的节点存在到同一个节点的路径，且这两个路径上没有其他的定义，那么这个节点属于DF<sup>+</sup>。在这两个规律基础上，我们提出一个应用于无循环的“无环图”的算法，并在结果上添加循环部分，得到最终DF<sup>+</sup>结果。</p><p>首先，对于无环图中的定义集合S，DF<sup>+</sup>(S)的计算过程如下：对控制流图使用拓扑顺序，利用前向数据流分析对满足两个不同节点到达同一个节点的情况进行分析，如果有多个节点可达节点x，则添加节点x到DF<sup>+</sup>(S)。例如上图中，节点6和节点8的即被多个定义到达，因此他们将会被加入至DF<sup>+</sup>(S)。该过程算法如下所示，其中UniqueReachingDef(v)记录了能到达节点v的唯一一个定义所在的基本块：</p><figure><imgsrc="https://gqrelic-blog-data.oss-cn-shanghai.aliyuncs.com/ssa-book-5-2022-04-23-23-56-32.png"alt="无环图中计算DF+的算法" /><figcaptionaria-hidden="true">无环图中计算DF<sup>+</sup>的算法</figcaption></figure><h3 id="将算法扩展至可规约图">将算法扩展至可规约图</h3><p>设HLC(v)为基本块v所在循环的循环头，那么对于集合S，存在公式如下。其中HLC(S)为S中所有节点所在循环头的集合，<spanclass="math inline">\(DF^+_{fwd}\)</span>为在无环图情况下求到的DF<sup>+</sup>集合。</p><p><span class="math display">\[DF^+(S)=HLC(S) \cup DF^+_{fwd}(S \cup HLC(S))\]</span></p><p>在之前的例子中，HLC({4,5,7,12})={2}，在无环图下得到的<spanclass="math inline">\(DF^+_{fwd}(\{2,4,5,7,12\})=\{6,8\}\)</span>，最终得到DF<sup>+</sup>(S)={2,6,8}。</p><h3 id="将算法扩展至不可规约图">将算法扩展至不可规约图</h3><p>不可规约图虽然在写代码的时候不容易出现，但是在优化的过程中经常出现。对于下图中的不可规约图，首先同样构建出他的循环森林。可以看到循环森林中循环头包括了两个节点，对应循环中的两个入口。在对不可规约图进行分析时，在无环图的基础上，添加一个辅助节点θ，我们连接所有循环头节点的前驱（u和s），并连接到循环头节点（v和w），最终得到图(d)。</p><figure><imgsrc="https://gqrelic-blog-data.oss-cn-shanghai.aliyuncs.com/ssa-book-5-2022-04-24-09-44-43.png"alt="不可规约图的变换策略" /><figcaption aria-hidden="true">不可规约图的变换策略</figcaption></figure><p>在这样的基础上，可以通过上一节的算法先计算无环图下的DF<sup>+</sup>，接着利用循环森林，计算最终的DF<sup>+</sup>集合。</p><h2 id="总结">总结</h2><p>尽管所有这些算法都比原始算法更好，但由于这些算法无法在同一个编译器框架中使用，因此很难分出最优最劣。在实际中，虽然构造整个DF+集在经典构造算法中看起来时间复杂度很高，但它的代价实际上没有那么高，因为我们需要为很多变量进行插入Φ函数的计算，这些计算之间的结果是可以复用的。此外，我们还可以用Reconstruction的过程代替重新的构造，避免构造时的计算成本。还要注意的是，在SSA构造过程中，重命名变量过程通常需要花费更多的时间。</p><p>在LLVM中的SSA有更好的优化方式，该部分参考文章<ahref="https://blog.csdn.net/qq_29674357/article/details/78731713">《LLVMSSA 介绍》</a>。LLVM并不会一开始就将整个程序转化成SSA的形式，他将变量分为了两个部分：虚拟寄存器和内存。其中虚拟寄存器满足SSA，而内存则使用alloca/load/store的方法，使得对变量的读写变成了对某个地址的操作。这个技术被称为“alloca+mem2reg”技术，在优化的过程中采用alloca的非SSA形式，避免了繁琐的SSA构造和重构等过程。而在需要将部分内存访问转化为寄存器访问时，则利用mem2reg将程序的IR转化成SSA形式，这样子大大提高了编译的效率。</p>]]></content>
    
    
    <categories>
      
      <category>编译</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SSA</tag>
      
      <tag>编译原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《SSA Book》- 4. SSA的基本析构算法</title>
    <link href="/2022/04/16/ssa-book-4/"/>
    <url>/2022/04/16/ssa-book-4/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="ssa-book--4.-ssa的基本析构算法">《SSA Book》- 4.SSA的基本析构算法</h1><p>本文对应原书3.2节，其介绍了如何对C-SSA进行最简单的析构，以及用简单的方法将T-SSA转化为C-SSA的方法。</p><p>SSA形式是为了在优化阶段能够更加高效和简单，当完成优化之后，就需要把他变成没有Φ函数的普通形式，这个过程称作SSA析构。</p><p>之前我们提到过，C-SSA的Φ网络中的变量具有互相不覆盖的live-ranges，这样子只需要做简单的指令替换，就可以完成SSA析构。析构的方法很简单，只需要在Φ函数的两个前驱基本块的末端增加两个复制语句。下图即为一个析构的例子：</p><figure><imgsrc="https://gqrelic-blog-data.oss-cn-shanghai.aliyuncs.com/ssa-book-4-2022-04-16-23-06-59.png"alt="面向C-SSA中Φ语句的析构方式" /><figcaption aria-hidden="true">面向C-SSA中Φ语句的析构方式</figcaption></figure><p>但是，针对上述过程存在一些问题：</p><ol type="1"><li>为什么有了live-ranges的互相重叠，就不能直接转换了呢？</li><li>如何将T-SSA转换为C-SSA呢？</li><li>基本快入口处的多个Φ函数是并行语句，转换后的复制语句是串行执行，如何进行转换呢？</li></ol><h2 id="朴素析构方法带来的问题">朴素析构方法带来的问题</h2><p>在对C-SSA的定义中提到了Φ函数对应的Φ-web。首先，如果x和y同时出现在同一个Φ函数中，x和y即为Φ-related的。所有被related到一起的变量构成了一个Φ-web。下面的算法利用并查集即可发现所有存在的Φ-web，union是并查集数据结构中的函数。</p><figure><imgsrc="https://gqrelic-blog-data.oss-cn-shanghai.aliyuncs.com/ssa-book-4-2022-04-17-21-04-24.png"alt="Φ-web发掘算法" /><figcaption aria-hidden="true">Φ-web发掘算法</figcaption></figure><p>接下来的这一部分困扰了我很久，我阅读原文理解的是：检测到Φ-web之后，如果存在Φ-web中活跃区间的冲突，则存在关键边上的问题，可能会导致lost-copyproblem和swapproblem，因此不能进行直接的Φ转换。但是，我实在没能理解为什么有活跃区间冲突后，就会导致这两个问题。</p><p>于是，我直接参考了论文《Practical Improvements to the Constructionand Destruction of Static Single AssignmentForm》。论文里面的逻辑关系感觉更容易理解。</p><h3 id="关键边critical-edges">关键边（Critical Edges）</h3><p>首先介绍关键边。关键边定义为具有多个后继块和具有多个前继块之间的边。图中的红色边即为关键边。当对Φ函数使用上面的方法进行分割后，如果程序沿着不通往φ函数的路径执行，那么不该发生的复制就会发生。</p><figure><imgsrc="https://gqrelic-blog-data.oss-cn-shanghai.aliyuncs.com/ssa-book-4-2022-04-19-22-00-53.png"alt="关键边以及析构Φ存在的问题" /><figcaption aria-hidden="true">关键边以及析构Φ存在的问题</figcaption></figure><p>为了解决这个现象，就需要将所有关键边分割开，然后再对Φ函数进行普通的替换。对于所有存在多个前驱的基本块B，判断每一个前驱是否具有其他的后继。如果Bi存在其他的后继，那么就在Bi和B之间添加一个基本快Bi'。遍历完毕后，再向新添加的基本块Bi'中增加赋值ai'=ai，并修改基本块B开头处的Φ语句中的ai为ai'。算法如下所示：</p><figure><imgsrc="https://gqrelic-blog-data.oss-cn-shanghai.aliyuncs.com/ssa-book-4-2022-04-17-22-57-26.png"alt="使T-SSA变成C-SSA的关键边分割算法" /><figcaptionaria-hidden="true">使T-SSA变成C-SSA的关键边分割算法</figcaption></figure><p>下图展示了变换的例子。添加基本块之后，之前提到的关键边带来的问题被消除了。</p><figure><imgsrc="https://gqrelic-blog-data.oss-cn-shanghai.aliyuncs.com/ssa-book-4-2022-04-17-23-23-16.png"alt="关键边分割实例" /><figcaption aria-hidden="true">关键边分割实例</figcaption></figure><p>上面最简单的关键边分割算法有很多问题：</p><ol type="1"><li>因为架构限制，异常处理代码等问题，编译器可能不允许分割给定的边；</li><li>添加大量复制操作可能会低效。虽然可以在后面的寄存器分配中进行合并（第22章中提到的合并启发式算法可以有效地移除这些副本），但是带着这么多复制进行编译也是不合适的。</li></ol><p>第21章会提出方法解决上面的问题。</p><h3 id="lost-copy-problem">Lost-Copy Problem</h3><p>关键边带来的复制语句的错误执行，在一定情况下会造成错误。典型的一个错误为：当进行Copyfolding优化之后，且存在一个或多个后向关键边时，将会发生“Lost-Copy”Problem。</p><p>下图即展示了“Lost-Copy”问题的例子。图(a)为原始的C-SSA。在进行复制传播之后，图(b)中变量y由x3进行了替代。图(c)显示了使用朴素算法将φ函数替换为复制语句的结果。显然，代码的结果发生了变化。而图(d)使用之前提到的关键边切割方法来解决问题。</p><figure><imgsrc="https://gqrelic-blog-data.oss-cn-shanghai.aliyuncs.com/ssa-book-4-2022-04-19-22-11-25.png"alt="导致Lost-Copy Problem的代码示例" /><figcaption aria-hidden="true">导致Lost-CopyProblem的代码示例</figcaption></figure><p>造成这一切原因的即为Copyfolding扩大了原先x3的活跃范围，这个活跃范围甚至覆盖了对x2的赋值。编译器在转换Φ函数的时候，必须要考虑插入的复制语句，对于非Φ函数的语句的后继基本块仍然有效。</p><h3 id="swap-problem">Swap Problem</h3><p>此外，同样是Copyfolding导致的另一个问题。下图给出了一个案例。图(a)为原始C-SSA，图(b)为进行了常量折叠之后的代码。图(c)显示了使用朴素算法将φ函数替换为复制语句的结果。因为Φ语句原来是并行执行的，而这样的直接转换破坏了并行特性，导致了a3与b3之间的互相干涉，使得结果错误。</p><figure><imgsrc="https://gqrelic-blog-data.oss-cn-shanghai.aliyuncs.com/ssa-book-4-2022-04-19-23-23-40.png"alt="导致Swap Problem的代码示例" /><figcaption aria-hidden="true">导致Swap Problem的代码示例</figcaption></figure><p>基本块开头的多个Φ函数在进行析构的过程中，将会为前驱添加多个复制语句。如果其中一个复制语句的结果，是另一个复制语句的操作数，那么复制语句的不同顺序则会对结果产生影响。下面的算法会自动保存上述复制语句的结果，以实现并行的效果。使用算法后可以得到上图中的图(d)，析构结果再次正确。</p><figure><imgsrc="https://gqrelic-blog-data.oss-cn-shanghai.aliyuncs.com/ssa-book-4-2022-04-18-21-17-58.png"alt="用顺序复制操作的序列替换并行Φ函数" /><figcaptionaria-hidden="true">用顺序复制操作的序列替换并行Φ函数</figcaption></figure><h2 id="对朴素析构算法的总结">对朴素析构算法的总结</h2><p>综上所述，进行了优化算法之后得到的T-SSA，存在Φ-web的变量干涉的现象。一旦存在变量干涉，则可能会导致如Lost-CopyProblem和SwapProblem这样的错误。针对这些错误，本章目前只讲了解决这些问题的最朴素方法（切割关键边，并行转串行语句的方法），后续会有更实际高效的析构方法。</p>]]></content>
    
    
    <categories>
      
      <category>编译</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SSA</tag>
      
      <tag>编译原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编译后端优化：If-Conversion算法与LLVM实现</title>
    <link href="/2022/04/14/back-end-opt-1/"/>
    <url>/2022/04/14/back-end-opt-1/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1id="编译后端优化if-conversion算法与llvm实现">编译后端优化：If-Conversion算法与LLVM实现</h1><p>在之前的某个项目中收到了这样的需求：给定一个无环控制流图，需要利用select等操作，消除其所有的分支，将其变成一个基本块。上网搜索现有轮子时，发现了大佬写的应用于GPU单指令多数据流的If-Conversion编译优化算法，能够很好地解决需求中的问题。于是我便照葫芦画瓢，直接在LLVM上实现了一个简单的Pass，并按照需求做了一些调整。</p><p>可能由于自身本领不够硬，看大佬的文章时理解得还是不太到位。因此我基于自己在实现Pass过程中的理解，简述一下这个算法，并对算法的某些部分在LLVM上的实现进行介绍，也算自己做一个笔记了。</p><p>附上大佬的文章地址：<ahref="https://zhuanlan.zhihu.com/p/157421035">针对GPU单指令多数据流的编译优化算法</a></p><h2 id="算法总览">算法总览</h2><p>使用Pass前后的数据流图如下图所示，稍微对具体内容做了一下屏蔽：</p><figure><imgsrc="https://gqrelic-blog-data.oss-cn-shanghai.aliyuncs.com/back-end-opt-1-2022-04-16-13-41-36.png"alt="Pass前后的数据流图对比" /><figcaption aria-hidden="true">Pass前后的数据流图对比</figcaption></figure><p>该Pass地实现整体可分为3个步骤，其中前2个步骤属于If-Conversion算法部分：</p><ol type="1"><li>计算控制依赖（Control Dependence，CD）；</li><li>谓词分析：计算每一个基本块被执行的条件，并将被执行的条件与实际条件变量绑定；</li><li>代码生成：基于分析结果生成新的代码。</li></ol><h2 id="step-1.-计算控制依赖">Step 1. 计算控制依赖</h2><h3 id="控制依赖定义">控制依赖定义</h3><p>首先，算法需要计算基本块之间的控制依赖关系。对于两个基本块X和Y，Y是X的控制依赖的条件是：</p><ol type="1"><li>从X到Y存在一条有向路径P，P中除X以外的任意基本块Z都被Y后继支配；</li><li>X不被Y后继支配。</li></ol><p>其中，后继支配的定义和支配类似，如果从节点y到出口节点的每一条路径都经过节点x，则x为y的后继支配节点，记作xpdom y。同样的，对于x pdom y，不存在节点z，使得x pdom z 且 z pdom y。则x为y的直接后继支配节点，记作x ipdom y。</p><p>对控制依赖的概念进行理解：当控制依赖的条件满足时，那么通过X可以跳转到多个路径上。如果能够跳转到路径P，那么所有到出口的路径一定会经过基本块Y，即基本块Y一定会被执行；如果跳转到其他路径，则Y就不一定被执行了。</p><p>那么，对于一个节点Y，如果我们能找到该节点控制依赖所有的节点集合，并且记录下这些控制依赖中的集合跳转到“必定执行Y”的路径的条件，那么就可以得到决定基本块Y是否被执行的充要条件。</p><p>以下图为例，以其中的节点6为待分析的基本块节点。根据控制依赖的条件2，首先排除掉基本块2、4、5、7。节点1和3同时满足条件1和2，因此节点6的控制依赖集合为{1,3}。其中当控制依赖集合跳转到标记为绿色的两条路径时，基本块6必将被执行。</p><figure><imgsrc="https://gqrelic-blog-data.oss-cn-shanghai.aliyuncs.com/back-end-opt-1-2022-04-15-23-05-00.png"alt="控制流图和其对应的控制依赖关系" /><figcaptionaria-hidden="true">控制流图和其对应的控制依赖关系</figcaption></figure><p>对基本块分支的不同选项进行编号，那么每个基本块对应的控制依赖可以用更具体的编号表示，例如基本块3的执行条件对应编号即为{-1}。</p><h3 id="计算控制依赖">计算控制依赖</h3><p>首先需要计算后置支配关系。在LLVM中，可以利用PostDominatorTree直接获得后置支配树PostDT，并通过PostDT-&gt;dominates(I,J)对基本块之间的后置支配关系进行判断。</p><p>其次，需要计算每个节点的直接后置支配节点。这个我在LLVM中没有找到对应的函数，因此直接使用了下面的算法。后继支配节点=直接后继支配节点+直接后继支配节点的后继支配节点，因此只需要删除所有“后继支配其他节点”的节点，剩下的即为直接后继支配节点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">for</span> CFG中的每一个节点n &#123;<br>    pdom(n) -= n;   <span class="hljs-comment">// 删除节点自己</span><br>&#125;<br><span class="hljs-keyword">for</span> CFG中的每一个节点n &#123;<br>    <span class="hljs-keyword">for</span> <span class="hljs-title function_">pdom</span><span class="hljs-params">(n)</span>中的每一个节点s &#123;<br>        <span class="hljs-keyword">for</span> <span class="hljs-title function_">pdom</span><span class="hljs-params">(n)</span>中的除去s的每一个节点t &#123;<br>            <span class="hljs-keyword">if</span> (t pdom s)   <span class="hljs-comment">// 删除“后继支配其他节点”的节点</span><br>                pdom(n) -= t;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面的表格展示了每个节点的后继支配和直接后继支配的结果。</p><table style="width:100%;"><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;">S</th><th style="text-align: center;">1</th><th style="text-align: center;">2</th><th style="text-align: center;">3</th><th style="text-align: center;">4</th><th style="text-align: center;">5</th><th style="text-align: center;">6</th><th style="text-align: center;">7</th><th style="text-align: center;">E</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">pdom</td><td style="text-align: center;">{E,7,1,S}</td><td style="text-align: center;">{E,7,1}</td><td style="text-align: center;">{E,7,6,2}</td><td style="text-align: center;">{E,7,3}</td><td style="text-align: center;">{E,7,6,4}</td><td style="text-align: center;">{E,7,6,5}</td><td style="text-align: center;">{E,7,6}</td><td style="text-align: center;">{E,7}</td><td style="text-align: center;">{E}</td></tr><tr class="even"><td style="text-align: center;">ipdom</td><td style="text-align: center;">1</td><td style="text-align: center;">7</td><td style="text-align: center;">6</td><td style="text-align: center;">7</td><td style="text-align: center;">6</td><td style="text-align: center;">6</td><td style="text-align: center;">7</td><td style="text-align: center;">7</td><td style="text-align: center;">{}</td></tr></tbody></table><p>得到每个节点的直接后继支配后，即可以计算控制依赖关系，可以直接通过控制依赖的两个条件得到，算法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">for</span> CFG中的边[x,y,label] &#123;  <span class="hljs-comment">// label为true表示X为true时跳转的边</span><br>    <span class="hljs-keyword">if</span> (y pdom x)<br>        <span class="hljs-keyword">continue</span>;   <span class="hljs-comment">// X不能被Y后继支配</span><br>    t = y;<br>    <span class="hljs-keyword">while</span>(t != ipdom(x)) &#123;<br>        CD(t) += x;<br>        t = ipdom(t);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上图例子中的控制流图为例，当分析边[1,2,true]时，t将依次遍历2，6，7。除了节点7之外的其他节点均满足“从1到这个节点路径上的所有节点都被该节点后继支配”。因此节点1将会被添加至CD(2)和CD(6)之中。其他边的计算方法同理，最终得到所有节点的控制依赖如下表所示，没有编号的即为一定会被执行的基本块：</p><table><thead><tr class="header"><th style="text-align: center;">n</th><th style="text-align: center;">1</th><th style="text-align: center;">2</th><th style="text-align: center;">3</th><th style="text-align: center;">4</th><th style="text-align: center;">5</th><th style="text-align: center;">6</th><th style="text-align: center;">7</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">CD(n)</td><td style="text-align: center;">{}</td><td style="text-align: center;">{1}</td><td style="text-align: center;">{-1}</td><td style="text-align: center;">{2}</td><td style="text-align: center;">{-2,3}</td><td style="text-align: center;">{1,3}</td><td style="text-align: center;">{}</td></tr></tbody></table><h2 id="step-2.-谓词分析">Step 2. 谓词分析</h2><p>首先，上述分析结果存在一个问题。比如对于基本块4，他的控制依赖集合是{2}，但是2是否执行取决于它的控制依赖集合{1}，即需要将基本块4的执行条件更新为{1,2}。这一步更新只需要使用简单的数据流方法更新即可。为了区别于控制依赖，对于基本块n，更新后的执行条件我们用K(n)表示，最终得到的结果为：</p><table><thead><tr class="header"><th style="text-align: center;">n</th><th style="text-align: center;">1</th><th style="text-align: center;">2</th><th style="text-align: center;">3</th><th style="text-align: center;">4</th><th style="text-align: center;">5</th><th style="text-align: center;">6</th><th style="text-align: center;">7</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">K(n)</td><td style="text-align: center;">{}</td><td style="text-align: center;">{1}</td><td style="text-align: center;">{-1}</td><td style="text-align: center;">{1,2}</td><td style="text-align: center;">{-2,3}</td><td style="text-align: center;">{1,3}</td><td style="text-align: center;">{}</td></tr></tbody></table><p>其次，这些基本块的控制依赖集合通常有多个元素，需要将多个元素的条件整合到同一个变量中，并利用该变量作为是否执行该基本快操作的前提。借用GPU里面的概念，我们把这些整合后得到的条件变量称作谓词（Predicate）。</p><p>谓词的生成其实比较简单。首先我们对上一步中分析得到的控制依赖集合进行一个编号，下图给出一个可能的编号结果，其中基本块n的编号为P(n)：</p><table><thead><tr class="header"><th style="text-align: center;">n</th><th style="text-align: center;">1</th><th style="text-align: center;">2</th><th style="text-align: center;">3</th><th style="text-align: center;">4</th><th style="text-align: center;">5</th><th style="text-align: center;">6</th><th style="text-align: center;">7</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">K(n)</td><td style="text-align: center;">{}</td><td style="text-align: center;">{1}</td><td style="text-align: center;">{-1}</td><td style="text-align: center;">{1,2}</td><td style="text-align: center;">{-2,3}</td><td style="text-align: center;">{1,3}</td><td style="text-align: center;">{}</td></tr><tr class="even"><td style="text-align: center;">P(n)</td><td style="text-align: center;">0</td><td style="text-align: center;">1</td><td style="text-align: center;">-1</td><td style="text-align: center;">2</td><td style="text-align: center;">3</td><td style="text-align: center;">4</td><td style="text-align: center;">0</td></tr></tbody></table><p>这样，我们可以创建4个谓词P1-P4。当基本块1和2尾端的跳转条件均为true时，谓词P2为true。基于谓词将控制流图改写成下列形式。其中“Px:By”的形式表示当谓词Px为true时，执行基本块By中的语句。Cy表示基本块By结尾处跳转时的条件变量。这样就完成了从带分支的控制流图到单个基本块的转变。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C">B1;<br>P1 = C1;<br>P1 : B2;<br>P2 = C1 &amp; C2;<br>!P1 : B3;<br>P3 = C1 &amp; C3;<br>P4 = !C2 &amp; C3;<br>P2 : B4;<br>P3 : B5;<br>P4 : B6;<br>B7;<br></code></pre></td></tr></table></figure><h2 id="step-3.-代码生成">Step 3. 代码生成</h2><p>这一步需要对LLVMIR进行更改，使指令全部被复制至一个基本块中。这里需要考虑两个问题：</p><ol type="1"><li>目标是否支持谓词的执行方式，如果不支持则要做一些面向目标的修改；</li><li>LLVM IR为SSA形式，要注意生成新的基本块时不要打破SSA约束。</li></ol><p>在这里，第一个问题涉及一些项目细节，就不展开介绍了。针对第二个问题，在我们使用IRBuilder或者其他方法创建新的Instruction时，需要使用RemapInstruction函数，将新的Inst和旧控制流图中的Inst绑定起来，这样子就可以保证最后生成的基本块满足SSA特性。绑定后即可通过ReplaceInstWithInst或者其他方法添加、替换、删除指令了。</p>]]></content>
    
    
    <categories>
      
      <category>编译</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译原理</tag>
      
      <tag>LLVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《SSA Book》- 3. SSA的基本构造算法</title>
    <link href="/2022/04/10/ssa-book-3/"/>
    <url>/2022/04/10/ssa-book-3/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="ssa-book--3.-ssa的基本构造算法">《SSA Book》- 3.SSA的基本构造算法</h1><p>上班了，更新速度明显减慢 /(ㄒoㄒ)/~~，争取每周能有2次更新。</p><p>原书中第三章包含了构造、析构、转换等多个算法，内容较长。因此将本章内容分为两节，本节先介绍利用支配树构造最小SSA的方法。</p><h2 id="最小ssa构造流程总览">最小SSA构造流程总览</h2><p>构造SSA的过程可以分为两步：放置Φ函数，变量重命名。针对Φ函数放置过程，本书采用构造支配树的方式，选取放置Φ函数的位置。其整体流程如下：</p><ol type="1"><li>构造支配树</li><li>计算变量的支配边界</li><li>在变量的支配边界添加Φ函数</li></ol><h2id="支配树dominator-tree与支配边界dominance-frontier">支配树（DominatorTree）与支配边界（Dominance Frontier）</h2><p>首先我们考虑最粗暴的方式，即在所有具有多个前驱的基本块开头添加Φ函数，对变量进行聚合。这样子虽然的确满足SSA的定义，但是会插入很多不必要的Φ函数。</p><p>假设一个程序的控制流图如下图所示，对于变量x，存在两个定义分别在基本块A和E中。其中，基本块D就具有多个前驱，按照最粗暴的算法，需要在这里放置一个Φ函数用来聚合前驱中变量x的值。很显然，此处的Φ函数是不必要的，因为基本块D处的x变量值是确定的。相对的，在基本块F添加Φ函数就是必要的了，因为变量x的值在此处是不确定的。</p><figure><imgsrc="https://gqrelic-blog-data.oss-cn-shanghai.aliyuncs.com/ssa-book-3-2022-04-10-15-45-31.png"alt="Fig 1. 在不同基本块添加Φ函数的必要性" /><figcaption aria-hidden="true">Fig 1.在不同基本块添加Φ函数的必要性</figcaption></figure><p>那么，在什么样的基本块添加Φ函数是必要的呢？这就需要支配树和支配边缘的概念了。关于支配的概念在龙书中提及：</p><blockquote><ul><li>支配（dominate）：如果所有从流图的入口结点entry到结点n的路径都经过结点d，则称d支配n，记为ddom n；</li><li>严格支配（strictly dominate）：如果d dom n且d !=n，那么d严格支配n，记为d sdom n；</li><li>直接支配（immediate dominate）：如果d domn且n的其他支配者都支配d，那么d直接支配n，记作d idom n。</li></ul></blockquote><p>直观的理解，当控制流图中存在d domn时，只要程序执行到基本块n，那么说明基本块d一定被执行过（反之不成立）。其中，直接支配和后续研究关系最大。在上图中存在的直接支配关系为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++">entry idom A; <br>A idom B;<br>A idom C;<br>A idom D;<br>A idom F;<br>C idom E;<br></code></pre></td></tr></table></figure><p>将所有的直接支配关系绘制成树的形式，即得到了支配树（DominatorTree）。上面例子的支配树如下图所示：</p><figure><imgsrc="https://gqrelic-blog-data.oss-cn-shanghai.aliyuncs.com/ssa-book-3-2022-04-10-16-31-58.png"alt="Fig 2. 对应支配树" /><figcaption aria-hidden="true">Fig 2. 对应支配树</figcaption></figure><p>在支配树中，我们仍然无法得到能决定“在F放置Φ函数是必要的，在D放置Φ函数是冗余”的原因，我们需要进一步计算支配边界（DominanceFrontier，DF）。支配边界的定义如下所示：</p><blockquote><p>基本块x的支配边界DF(x)是满足下列条件的所有w的集合：x支配w的一个前驱，但是不严格支配w。</p></blockquote><p>以图1中的程序为例求解DF(C)，首先排除所有C严格支配的基本块（E）。剩下的基本块中，C支配D的前驱（C）和F的前驱（E），因此DF(C)={D,F}。类似的，对于与变量x相关的两个基本块A和E，他们的支配边界为DF(A)={Ø}，DF(E)={F}。</p><p>支配边界是支配节点和非支配节点的分界线。每一个基本块都有其支配的节点的集合。如果一个定义了变量的基本块的所有支配的基本块中，没有别的对这个变量的定义，那么这些被支配基本块中该变量的值是确定的。一旦到了支配边界，这个变量具体的值就要考虑这个支配边界的其他的前驱基本块了。因此，变量的支配边界均为Φ函数的候选点。</p><p>在之前的例子中，存在x定义的基本块集合{A,E}的支配边界集合为{F}，因此要在基本块F的开始处添加φ函数。当添加了Φ函数后，基本块F中也存在x的定义了，因此需要对{A,E,F}重复进行支配边界分析。由于DF(F)={}，因此φ函数添加完毕。</p><h2 id="添加φ节点的具体算法实现">添加Φ节点的具体算法实现</h2><p>针对上一节给出的例子，本节将会给出构造SSA过程各部分的算法实现。</p><h3 id="支配树与支配边界构造算法">支配树与支配边界构造算法</h3><p>在SSAbook中没有对构造支配树的方法进行介绍，经典支配树构造的算法包括SLT和semi-NCA算法，可以参考文章：https://zhuanlan.zhihu.com/p/365912693。</p><p>当得到基本块之间的支配关系后，即可通过下面的算法构造每一个基本块的支配边界。</p><figure><imgsrc="https://gqrelic-blog-data.oss-cn-shanghai.aliyuncs.com/ssa-book-3-2022-04-12-21-30-26.png"alt="Alg 1. 计算控制流图的支配边界" /><figcaption aria-hidden="true">Alg 1.计算控制流图的支配边界</figcaption></figure><p>以下图(a)中的数据流图为例，我们使用上面的算法进行分析。所有边中，非严格支配的边的集合只有D→E和F→G。图(b)中对控制流图进行重整，并标注出非严格支配边，这张图被称作DJ-graph（Dominanceedges &amp; Join edges），非严格支配的边被称作Joinedge（J-edge）。接着，对于这些J-edge使用算法。节点E被先后添加至DF(D)与DF(C)中，而节点G被添加至DF(F)、DF(E)与DF(B)中。图(c)中的边即为节点和该节点的支配边界间的连线。</p><figure><imgsrc="https://gqrelic-blog-data.oss-cn-shanghai.aliyuncs.com/ssa-book-3-2022-04-12-21-53-46.png"alt="Fig 3. 示例控制流图和其对应的DJ-grpah，DF-graph以及DF+-graph" /><figcaption aria-hidden="true">Fig 3.示例控制流图和其对应的DJ-grpah，DF-graph以及DF<sup>+</sup>-graph</figcaption></figure><p>此外，图(d)中展示了DF-graph图上的扩展。针对DF-graph中的连续边如C→E和E→G，将会添加边C→G到DF<sup>+</sup>-graph图中。之前提到过Φ节点的添加是迭代式的，添加的Φ函数本身也是一个def。假设在基本块C存在对变量x的定义，当向E添加了Φ函数之后，由于E有了关于变量x的定义，因此需要向基本块G继续添加Φ函数。提前计算好DF<sup>+</sup>-graph能避免计算支配边界过程中的冗余计算。这部分算法将会在第四章中“更复杂巧妙的构造算法”进行介绍。</p><h3 id="φ函数添加算法">Φ函数添加算法</h3><p>基于前文的分析，添加Φ函数的方法显而易见了。下图展示了插入Φ节点的标准算法。对于一个变量，算法将所有的定义所在基本块添加至集合W中。然后从W中取出基本块X，向X的支配边界添加Φ函数，并把添加了Φ函数的基本块添加至集合W中。如此循环直到W集合为空。</p><figure><imgsrc="https://gqrelic-blog-data.oss-cn-shanghai.aliyuncs.com/ssa-book-3-2022-04-12-22-06-40.png"alt="Alg 2. 向控制流图中添加Φ函数" /><figcaption aria-hidden="true">Alg 2. 向控制流图中添加Φ函数</figcaption></figure><h2 id="变量重命名">变量重命名</h2><p>添加了Φ函数之后，需要对变量进行重命名。变量重命名算法如下图所示。对于任意一个变量v，算法使用v.reachingDef来记录当前替换变量的值。算法前序遍历支配树中的基本块，并依次遍历基本块中的每一条指令。进行操作：</p><ol type="1"><li>如果该语句非Φ函数，且使用了变量v，那么则更新v.reachingDef的值，并用更新后v.reachingDef的值替代此处变量v；</li><li>如果被该语句定义了变量v，那么同样先更新v.reachingDef的值，并创建一个新变量v'替代此处的定义，并对v和v'的reachingDef属性进行更改；</li><li>当遍历完所有语句，则对于所有这个基本块的后继基本块的Φ函数，如果Φ函数使用了变量v，则采用类似操作1中的方法，对Φ函数中的变量进行替代。</li></ol><figure><imgsrc="https://gqrelic-blog-data.oss-cn-shanghai.aliyuncs.com/ssa-book-3-2022-04-13-20-39-50.png"alt="Alg 3. 变量重命名算法" /><figcaption aria-hidden="true">Alg 3. 变量重命名算法</figcaption></figure><p>上述算法中，最重要的就是“更新v.reachingDef的值”的方法，该方法被包含在函数updateReachingDef(v,i)中，算法如下所示。这个算法搜索v的所有定义，直到找到支配i的最接近的定义（注意是支配，而不是严格支配），然后使用此定义更新v.reachingDef。这样子语句i被v.reachingDef的定义所支配，因此i中的变量v理所当然的可以被v.reachingDef所替换。</p><figure><imgsrc="https://gqrelic-blog-data.oss-cn-shanghai.aliyuncs.com/ssa-book-3-2022-04-13-20-41-26.png"alt="Alg 4. updateReachingDef(v,i)函数实现" /><figcaption aria-hidden="true">Alg 4.updateReachingDef(v,i)函数实现</figcaption></figure><p>下图以一个例子展示了对程序中x变量重命名的全过程，按步骤进行简单介绍：</p><ol type="1"><li>在入口处对x.reachingDef进行初始化；</li><li>语句l1满足情况2，首先更新reachingDef的值为当前语句，然后将def的结果替换为x1；</li><li>遍历完基本块A的两个语句，需要看两个后继中的Φ语句。刚好都没有Φ语句，那没事了，继续遍历；</li><li>类似的，基本块B的l2语句情况类似，同样更新reachingDef的值为当前语句，替换为x2；</li><li>遍历完B，需要查看后继中的Φ语句。对于l5中的use，需要根据情况3进行更新。这个时候最近的支配def即为B中的x2，因此将其替换为x2；</li><li>接着回到基本块C，C中出现的l3语句满足情况1，支配l3的定义为基本块A中的l1，因此将其替换为x1；</li><li>情况1-3展示完毕，后续同理……</li></ol><p>对于reachingDef属性的具体存储，因为其包含了一些搜索和回退过程，在实现的过程中通常会分配额外的内存对过程值进行记录。记录的方法包括使用栈和槽（slot-based）的，前者更节省空间，后者更加高效。</p><figure><imgsrc="https://gqrelic-blog-data.oss-cn-shanghai.aliyuncs.com/ssa-book-3-2022-04-13-21-15-20.png"alt="Fig 4. 变量重命名的过程实例" /><figcaption aria-hidden="true">Fig 4. 变量重命名的过程实例</figcaption></figure><h2 id="关于基本ssa构造方法的总结">关于基本SSA构造方法的总结</h2><p>使用本章最简单的构造方法得到的SSA具有下列特点：</p><ol type="1"><li>它是minimal SSA；</li><li>它是non-pruned SSA，有些插入的Φ函数可能是dead的，需要删除；</li><li>它是C-SSA，可以被直接送到SSA析构算法中进行转化；</li><li>它是strictSSA，即每个use都一个def所支配。这是因为它在构造过程中采用了支配边界的概念进行Φ函数插入，而不是简单的通过joinset进行判断（注：基本块集合S的joinset即为在CFG中可以被S的两个或更多不同元素通过不相交路径到达的节点）。</li></ol>]]></content>
    
    
    <categories>
      
      <category>编译</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SSA</tag>
      
      <tag>编译原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《SSA Book》- 2. SSA种类和特性</title>
    <link href="/2022/04/09/ssa-book-2/"/>
    <url>/2022/04/09/ssa-book-2/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="ssa-book--2.-ssa种类和特性">《SSA Book》- 2. SSA种类和特性</h1><p>本章首先介绍了SSA和non-SSA下的def-use链特性进行了分析。同时本章介绍了几种不同形式的SSA，包括最小SSA（MinimalSSA）、严格SSA（Strict SSA）、剪枝SSA（PrunedSSA）和常规和转换SSA（Conventional and transformed SSA）</p><h2 id="def-use与use-def链">Def-use与use-def链</h2><p>Def-use与use-def链并不是SSA特有的东西，非SSA形式下的每一个变量的所有def和use之间仍然存在def-use与use-def链。但是在非SSA形式中，由于存在多个def和use，需要用类似二维数组的形式，对变量所有的def和use之间的关系进行记录。然而，在SSA形式中每个变量只被def一次。因此每个变量仅需记录所有它的use，每一个use都对应了一条def-usechain，这样就可以用更为稀疏的形式对def-use关系进行存储。</p><p>SSA形式下的def-use与use-def链的优势可以总结为：</p><ol type="1"><li>数量相较non-SSA下普遍更少，并且更加便于数据存储；</li><li>更加方便数据流分析。SSA形式下的数据流分析只需要在def处保存数据流分析信息。在更新某一个def的数据流信息时，可以直接利用该条def所使用的变量对应的use-def链，获得存储在其他def处的数据流信息。</li></ol><h2 id="不同形式的ssa">不同形式的SSA</h2><p>在满足SSA定义“每个变量在程序中有且只有一个赋值语句”的前提下，Φ函数可以被插入到程序中不同的位置，因此同一个程序对应的SSA形式不是唯一的。通过增加更多约束，可以细分为不同SSA类型。</p><h3 id="最小ssaminimal-ssa">最小SSA（Minimal SSA）</h3><p>最小SSA指代的是“Φ函数数量最小的SSA形式”。构建SSA的过程包含两个阶段：放置Φ函数、变量重命名。在放置的过程中，为同一个原始变量两个不同定义到出口的所有路径交汇处添加Φ函数，既能构成具有Minimality特性的最小SSA形式。在下一章中展示的构造SSA方式即为构造最小SSA的方法。</p><blockquote><p>TODO：为什么这样生成就能得到Minimal SSA呢？</p></blockquote><h3 id="严格ssastrict-ssa">严格SSA（Strict SSA）</h3><p>如果每个变量在从入口到出口的每条路径上，use之前都已被def，那么SSA是严格的。利用支配（dominate）的概念对其进行描述，若SSA中每个use被其def支配，那么称为严格SSA。下图展示了non-strict和strictSSA。相较图(a)中的SSA形式，图(b)中新添加了两个Φ函数。很明显，图(b)中的SSA并不是MinimalSSA。</p><figure><imgsrc="https://gqrelic-blog-data.oss-cn-shanghai.aliyuncs.com/ssa-book-2-2022-04-09-18-34-30.jpg"alt="non-strict SSA及其对应的strict SSA。⊥表示未定义的值" /><figcaption aria-hidden="true">non-strict SSA及其对应的strictSSA。⊥表示未定义的值</figcaption></figure><p>严格SSA带来的好处主要在特定算法中体现，包括：</p><ol type="1"><li>更好判断在一个点上，变量是否是活跃的（Live），可以应用于到达定值分析等；</li><li>测试两个变量是否相互干涉（interfere），可以用作图染色中，不需要另外显式构造变量间干涉图。</li></ol><h3 id="剪枝ssapruned-ssa">剪枝SSA（Pruned SSA）</h3><p>剪枝SSA是在最小SSA的基础上，添加约束“如果变量在基本块的入口处不是活跃的，就不必插入Φ函数”。以下图为例，图(a)是没有经过修剪的最小SSA形式，在经过了值编号（Valuenumbering）之后，Z1与Z2被认为是死变量，Z3与Y3具有相同的值。因此，关于Z3的Φ函数被删除，得到了图(b)中的剪枝SSA。</p><figure><imgsrc="https://gqrelic-blog-data.oss-cn-shanghai.aliyuncs.com/ssa-book-2-2022-04-09-22-07-40.png"alt="剪枝前后的SSA" /><figcaption aria-hidden="true">剪枝前后的SSA</figcaption></figure><p>可以发现，剪枝SSA的Φ函数数量可以小于最小SSA中的数量。这是因为最小SSA的minimality是指的是“不在生成的SSA上进行优化”前提下的Φ函数数量最小，而剪枝则对SSA本身进行了优化。</p><p>针对剪枝具体进行的阶段，书中给出了两种策略：</p><ol type="1"><li>先建立好最小SSA，然后进行死代码消除</li><li>在构造SSA的时候，对Φ函数进行活跃分析，删除不活跃的Φ函数</li></ol><p>第三章提出了半剪枝SSA（Semi-prunedSSA）。因为剪枝SSA需要进行活跃变量分析，有较高的代价，所以可以考虑先把最小SSA变成半剪枝SSA的形式。半剪枝SSA对只存在于单个基本块中的局部变量生成的Φ函数进行消除。这样，在进行活跃变量分析时，部分变量被消除，活跃分析代价变少。</p><blockquote><p>注：LLVM中使用Mem2reg构建SSA时，即为通过半剪枝SSA构造剪枝SSA的方法。</p></blockquote><h3 id="conventional-ssa和transformed-ssa">Conventional SSA和TransformedSSA</h3><p>如果两个变量的活动范围（Live-range）相交，它们就会相互干涉（interference）。从Φ函数出发，到所有Φ函数参数的定义连接起来，可以构成一个网络。当网络中的变量活跃范围互相不干涉时，则被称作传统（ConventionalSSA，C-SSA）。对C-SSA进行优化之后，可能会破坏这个性质，即被称作变形SSA（TransformedSSA，T-SSA）。</p><p>下图展示了同一个控制流图的不同状态。图(a)为原始控制流图，图(b)为添加Φ函数并且重命名之后的SSA。这个SSA是最小SSA，同时也是C-SSA。在C-SSA的基础上进行复制传播（copypropagation），即可得到图(c)。可以发现，Φ函数中两个变量的网络在第一个基本块上重合，因此为T-SSA。</p><figure><imgsrc="https://gqrelic-blog-data.oss-cn-shanghai.aliyuncs.com/ssa-book-2-2022-04-09-23-23-25.png"alt="复制传播将C-SSA转化成T-SSA" /><figcaption aria-hidden="true">复制传播将C-SSA转化成T-SSA</figcaption></figure><p>C-SSA形式在对SSA进行析构时（即将其转化为实际机器代码的过程）具有优势：C-SSA的析构过程是很简单的，直接将所有的定义和使用都被重命名以使用新变量，并且删除所有涉及这个等价类的Φ函数。以上图(b)为例，变量a2和a3被重命名为新的单独的变量，对应的Φ函数a4直接被删除。因此，在析构SSA过程中，首先要将T-SSA转化成C-SSA的形式。通常这个转化过程通过添加复制操作来完成。</p><p>其次，C-SSA形式更易于部分算法获得一些SSA的特性，这些特性在T-SSA中可能是难以被发现的。例如局部冗余消除（PRE）就利用了这些特性（第11章）。</p><p>除了以上两种情况，通常情况下都不会主动去维护SSA的Conventional性质。</p><h2id="关于干涉interference的进一步讨论">关于干涉（interference）的进一步讨论</h2><p>干涉概念的最终目的，是为了标明两个变量是否能通过同一个寄存器暂存。在之前的定义中，两个变量的live-range重叠，则认为两个变量是互相干涉的。这个对于干涉的定义实际上有些严苛了。实际上，可能存在“两个变量互相不干涉，但是他们live-range重叠”的情况。下面给出两个例子：</p><ol type="1"><li>如果两个变量在任何时间点都具有相同的值，那么他们之间是不干涉的；</li><li>可能两个变量的live-range在静态分析时是重叠的，但是可能会因为特殊的基本块跳转条件，导致实际执行时两个变量不会在同一时刻活跃，那么他们之间也是不干涉的。</li></ol><p>以上两个特例大多是可以通过静态分析过程发现的，这种优化后的干涉定义相较于简单且严苛的干涉定义，能使得部分算法取得更好的结果。</p>]]></content>
    
    
    <categories>
      
      <category>编译</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SSA</tag>
      
      <tag>编译原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《SSA Book》- 1. 介绍</title>
    <link href="/2022/04/07/ssa-book-1/"/>
    <url>/2022/04/07/ssa-book-1/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="ssa-book--1.-介绍">《SSA Book》- 1. 介绍</h1><p>在知乎的编译优化相关书籍推荐中，看到了很多关于这本书的推荐，但是国内论坛关于这本书的讨论相对较少。《SSABook》从静态单赋值SSA的定义出发，讨论了构造、变换后重构、以及在SSA形式下不同编译算法的执行方式。此外，本书还介绍了很多高级SSA表示和用法，如果将来有时间，争取能对这部分进行补充。</p><h2 id="ssa的定义以及φ函数特性">SSA的定义以及Φ函数特性</h2><p>关于SSA的定义的文章遍地都是，就不在这里赘述了，只给出SSA的两个简单特性：</p><ol type="1"><li>每个变量在程序中有且只有一个赋值语句；</li><li>Φ函数将会被添加至控制流图中的控制流交汇点，用于聚合来自不同分支中的变量值。</li></ol><p>Φ函数的功能是很容易理解的，但是在计算机执行过程中，Φ函数究竟对应什么指令呢？书中针对这个问题进行了解答。Φ函数只存在于静态编译分析过程中，这些语句并不对应着目标硬件上某条指令。在SSA解构阶段，这些Φ函数将会被删除，并使用传统的复制操作对其进行序列化。此外，在部分SSAform中，同样存在部分扩展使得Φ函数存在对应的可执行指令，关于此部分将会在高级部分中进行讨论。</p><h2 id="ssa的优势">SSA的优势</h2><p>SSA最大优势来源于简化了数据流分析过程。传统数据流分析需要在每一个程序点处捕捉变量的信息，并利用格和流函数等概念，对这些程序点的信息值进行多次计算，得到不动点等信息。这使得在程序中每个程序点，都需要记录此处在数据流分析过程中信息的值，并在每一次运算过程中计算所有的值，即使在这些程序点中大部分信息没有改变。</p><p>然而，SSA形式下的数据流分析可以基于每个变量的def-use链进行分析。分析过程只需要记录每个变量定义处的信息，并通过def-use链更新信息。这大大减少了数据流分析的复杂度。这也使得程序员能够更加容易地编写数据流分析算法，调试难度更低。</p><p>下图中展示了传统形式和SSA形式下对于程序中x与y两个变量的零值传播分析对比。图(a)中在每个基本块的入口和出口处均设置了信息槽，用于记录当前位置x和y变量的值是否为0。可以看出，在大多数与两个变量无关的基本块处，入口和出口的信息是没有变化的，这造成了一定的浪费。</p><p>图(b)中展示了基于SSA形式下的数据流分析过程，可以发现，只需要在每个基本块的结尾设置与该基本块中定义的变量相关的信息槽，即可完成对整个控制流图的数据分析。在SSA形式下，需要的信息槽数量明显减少，数据流分析的效率可以得到提升。</p><figure><imgsrc="https://gqrelic-blog-data.oss-cn-shanghai.aliyuncs.com/ssa-book-1-2022-04-08-09-55-37.jpg"alt="使用SSA分析的控制流图示例" /><figcaption aria-hidden="true">使用SSA分析的控制流图示例</figcaption></figure><h2 id="关于ssa存在的谬论">关于SSA存在的谬论</h2><p>一部分人认为SSA可能存在一部分缺点，然而实际上针对这些缺点已经有了很好的解决方法。本书将会在后续部分中对这些可能存在的进行研究和解释。此处先给出部分SSA可能存在的缺点，以及对这些缺点进行讨论的章节：</p><table><thead><tr class="header"><th>SSA可能存在的缺点</th><th>解决策略</th></tr></thead><tbody><tr class="odd"><td>SSA增加了变量的数量</td><td>第2章展示了减少变量数量的优化方法</td></tr><tr class="even"><td>SSA难以维护</td><td>第3和5章展示了编译优化过程中对SSA结构的高效维护策略</td></tr><tr class="odd"><td>SSA析构时将带来大量复制操作</td><td>第3和21章展示了高效的SSA析构策略</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>编译</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SSA</tag>
      
      <tag>编译原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
