<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>《SSA Book》- 3.1. SSA的标准构造算法</title>
    <link href="/2022/04/10/ssa-book-3/"/>
    <url>/2022/04/10/ssa-book-3/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="ssa-book--3.1.-ssa的标准构造算法">《SSA Book》- 3.1.SSA的标准构造算法</h1><p>上班了，更新速度明显减慢 /(ㄒoㄒ)/~~，争取每周能有2次更新。</p><p>原书中第三章包含了构造、析构、转换等多个算法，内容较长。因此将本章内容分为两节，本节先介绍利用支配树构造最小SSA的方法。</p><h2 id="最小ssa构造流程总览">最小SSA构造流程总览</h2><p>构造SSA的过程可以分为两步：放置Φ函数，变量重命名。针对Φ函数放置过程，本书采用构造支配树的方式，选取放置Φ函数的位置。其整体流程如下：</p><ol type="1"><li>构造支配树</li><li>计算变量的支配边界</li><li>在变量的支配边界添加Φ函数</li></ol><h2id="支配树dominator-tree与支配边界dominance-frontier">支配树（DominatorTree）与支配边界（Dominance Frontier）</h2><p>首先我们考虑最粗暴的方式，即在所有具有多个前驱的基本块开头添加Φ函数，对变量进行聚合。这样子虽然的确满足SSA的定义，但是会插入很多不必要的Φ函数。</p><p>假设一个程序的控制流图如下图所示，对于变量x，存在两个定义分别在基本块A和E中。其中，基本块D就具有多个前驱，按照最粗暴的算法，需要在这里放置一个Φ函数用来聚合前驱中变量x的值。很显然，此处的Φ函数是不必要的，因为基本块D处的x变量值是确定的。相对的，在基本块F添加Φ函数就是必要的了，因为变量x的值在此处是不确定的。</p><figure><imgsrc="https://gqrelic-blog-data.oss-cn-shanghai.aliyuncs.com/ssa-book-3-2022-04-10-15-45-31.png"alt="Fig 1. 在不同基本块添加Φ函数的必要性" /><figcaption aria-hidden="true">Fig 1.在不同基本块添加Φ函数的必要性</figcaption></figure><p>那么，在什么样的基本块添加Φ函数是必要的呢？这就需要支配树和支配边缘的概念了。关于支配的概念在龙书中提及：</p><blockquote><ul><li>支配（dominate）：如果所有从流图的入口结点entry到结点n的路径都经过结点d，则称d支配n，记为ddom n；</li><li>严格支配（strictly dominate）：如果d dom n且d !=n，那么d严格支配n，记为d sdom n；</li><li>直接支配（immediate dominate）：如果d domn且n的其他支配者都支配d，那么d直接支配n，记作d idom n。</li></ul></blockquote><p>直观的理解，当控制流图中存在d domn时，只要程序执行到基本块n，那么说明基本块d一定被执行过（反之不成立）。其中，直接支配和后续研究关系最大。在上图中存在的直接支配关系为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++">entry idom A; <br>A idom B;<br>A idom C;<br>A idom D;<br>A idom F;<br>C idom E;<br></code></pre></td></tr></table></figure><p>将所有的直接支配关系绘制成树的形式，即得到了支配树（DominatorTree）。上面例子的支配树如下图所示：</p><figure><imgsrc="https://gqrelic-blog-data.oss-cn-shanghai.aliyuncs.com/ssa-book-3-2022-04-10-16-31-58.png"alt="Fig 2. 对应支配树" /><figcaption aria-hidden="true">Fig 2. 对应支配树</figcaption></figure><p>在支配树中，我们仍然无法得到能决定“在F放置Φ函数是必要的，在D放置Φ函数是冗余的原因”，我们需要进一步计算支配边界（DominanceFrontier，DF）。支配边界的定义如下所示：</p><blockquote><p>基本块x的支配边界DF(x)是满足下列条件的所有w的集合：x支配w的一个前驱，但是不严格支配w。</p></blockquote><p>以图1中的程序为例求解DF(C)，首先排除所有C严格支配的基本块（E）。剩下的基本块中，C支配D的前驱（C）和F的前驱（E），因此DF(C)={D,F}。类似的，对于与变量x相关的两个基本块A和E，他们的支配边界为DF(A)={Ø}，DF(E)={F}。</p><p>支配边界是支配节点和非支配节点的分界线。每一个基本块都有其支配的节点的集合。如果一个定义了变量的基本块的所有支配的基本块中，没有别的对这个变量的定义，那么这些被支配基本块中该变量的值是确定的。一旦到了支配边界，这个变量具体的值就要考虑这个支配边界的其他的前驱基本块了。因此，变量的支配边界均为Φ函数的候选点。</p><p>在之前的例子中，存在x定义的基本块集合{A,E}的支配边界集合为{F}，因此要在基本块F的开始处添加φ函数。当添加了Φ函数后，基本块F中也存在x的定义了，因此需要对{A,E,F}重复进行支配边界分析。由于DF(F)={}，因此φ函数添加完毕。</p><h2 id="添加φ节点的具体算法实现">添加Φ节点的具体算法实现</h2><p>针对上一节给出的例子，本节将会给出构造SSA过程各部分的算法实现。</p><h3 id="支配树与支配边界构造算法">支配树与支配边界构造算法</h3><p>在SSAbook中没有对构造支配树的方法进行介绍，经典支配树构造的算法包括SLT和semi-NCA算法，可以参考文章：https://zhuanlan.zhihu.com/p/365912693。</p><p>当得到基本块之间的支配关系后，即可通过下面的算法构造每一个基本块的支配边界。</p><figure><imgsrc="https://gqrelic-blog-data.oss-cn-shanghai.aliyuncs.com/ssa-book-3-2022-04-12-21-30-26.png"alt="Alg 1. 计算控制流图的支配边界" /><figcaption aria-hidden="true">Alg 1.计算控制流图的支配边界</figcaption></figure><p>以下图(a)中的数据流图为例，我们使用上面的算法进行分析。所有边中，非严格支配的边的集合只有D→E和F→G。图(b)中对控制流图进行重整，并标注出非严格支配边，这张图被称作DJ-graph（Dominanceedges &amp; Join edges），非严格支配的边被称作Joinedge（J-edge）。接着，对于这些J-edge使用算法。节点E被先后添加至DF(D)与DF(C)中，而节点G被添加至DF(F)、DF(E)与DF(B)中。图(c)中的边即为节点和该节点的支配边界间的连线。</p><figure><imgsrc="https://gqrelic-blog-data.oss-cn-shanghai.aliyuncs.com/ssa-book-3-2022-04-12-21-53-46.png"alt="Fig 3. 示例控制流图和其对应的DJ-grpah，DF-graph以及DF+-graph" /><figcaption aria-hidden="true">Fig 3.示例控制流图和其对应的DJ-grpah，DF-graph以及DF+-graph</figcaption></figure><p>此外，图(d)中展示了DF-graph图上的扩展。针对DF-graph中的连续边如C→E和E→G，将会添加边C→G到DF+-graph图中。之前提到过Φ节点的添加是迭代式的，添加的Φ函数本身也是一个def。假设在基本块C存在对变量x的定义，当向E添加了Φ函数之后，由于E有了关于变量x的定义，因此需要向基本块G继续添加Φ函数。提前计算好DF+-graph能避免计算支配边界过程中的冗余计算。这部分算法将会在第四章中“更复杂巧妙的构造算法”进行介绍。</p><h3 id="φ函数添加算法">Φ函数添加算法</h3><p>基于前文的分析，添加Φ函数的方法显而易见了。下图展示了插入Φ节点的标准算法。对于一个变量，算法将所有的定义所在基本块添加至集合W中。然后从W中取出基本块X，向X的支配边界添加Φ函数，并把添加了Φ函数的基本块添加至集合W中。如此循环直到W集合为空。</p><figure><imgsrc="https://gqrelic-blog-data.oss-cn-shanghai.aliyuncs.com/ssa-book-3-2022-04-12-22-06-40.png"alt="Alg 2. 向控制流图中添加Φ函数" /><figcaption aria-hidden="true">Alg 2. 向控制流图中添加Φ函数</figcaption></figure><h2 id="变量重命名">变量重命名</h2><p>添加了Φ函数之后，需要对变量进行重命名。变量重命名算法如下图所示。对于任意一个变量v，算法使用v.reachingDef来记录当前替换变量的值。算法前序遍历支配树中的基本块，并依次遍历基本块中的每一条指令。进行操作：</p><ol type="1"><li>如果该语句非Φ函数，且使用了变量v，那么则更新v.reachingDef的值，并用更新后v.reachingDef的值替代此处变量v；</li><li>如果被该语句定义了变量v，那么同样先更新v.reachingDef的值，并创建一个新变量v'替代此处的定义，并对v和v'的reachingDef属性进行更改；</li><li>当遍历完所有语句，则对于所有这个基本块的后继基本块的Φ函数，如果Φ函数使用了变量v，则采用类似操作1中的方法，对Φ函数中的变量进行替代。</li></ol><figure><imgsrc="https://gqrelic-blog-data.oss-cn-shanghai.aliyuncs.com/ssa-book-3-2022-04-13-20-39-50.png"alt="Alg 3. 变量重命名算法" /><figcaption aria-hidden="true">Alg 3. 变量重命名算法</figcaption></figure><p>上述算法中，最重要的就是“更新v.reachingDef的值”的方法，该方法被包含在函数updateReachingDef(v,i)中，算法如下所示。这个算法搜索v的所有定义，直到找到支配i的最接近的定义（注意是支配，而不是严格支配），然后使用此定义更新v.reachingDef。这样子语句i被v.reachingDef的定义所支配，因此i中的变量v理所当然的可以被v.reachingDef所替换。</p><figure><imgsrc="https://gqrelic-blog-data.oss-cn-shanghai.aliyuncs.com/ssa-book-3-2022-04-13-20-41-26.png"alt="Alg 4. updateReachingDef(v,i)函数实现" /><figcaption aria-hidden="true">Alg 4.updateReachingDef(v,i)函数实现</figcaption></figure><p>下图以一个例子展示了对程序中x变量重命名的全过程，按步骤进行简单介绍：</p><ol type="1"><li>在入口处对x.reachingDef进行初始化；</li><li>语句l1满足情况2，首先更新reachingDef的值为当前语句，然后将def的结果替换为x1；</li><li>遍历完基本块A的两个语句，需要看两个后继中的Φ语句。刚好都没有Φ语句，那没事了，继续遍历；</li><li>类似的，基本块B的l2语句情况类似，同样更新reachingDef的值为当前语句，替换为x2；</li><li>遍历完B，需要查看后继中的Φ语句。对于l5中的use，需要根据情况3进行更新。这个时候最近的支配def即为B中的x2，因此将其替换为x2；</li><li>接着回到基本块C，C中出现的l3语句满足情况1，支配l3的定义为基本块A中的l1，因此将其替换为x1；</li><li>情况1-3展示完毕，后续同理……</li></ol><p>对于reachingDef属性的具体存储，因为其包含了一些搜索和回退过程，在实现的过程中通常会分配额外的内存对过程值进行记录。记录的方法包括使用栈和槽（slot-based）的，前者更节省空间，后者更加高效。</p><figure><imgsrc="https://gqrelic-blog-data.oss-cn-shanghai.aliyuncs.com/ssa-book-3-2022-04-13-21-15-20.png"alt="Fig 4. 变量重命名的过程实例" /><figcaption aria-hidden="true">Fig 4. 变量重命名的过程实例</figcaption></figure><h2 id="关于基本ssa构造方法的总结">关于基本SSA构造方法的总结</h2><p>使用本章最简单的构造方法得到的SSA具有下列特点：</p><ol type="1"><li>它是minimal SSA；</li><li>它是non-pruned SSA，有些插入的Φ函数可能是dead的，需要删除；</li><li>它是C-SSA，可以被直接送到SSA析构算法中进行转化；</li><li>它是strictSSA，即每个use都一个def所支配。这是因为它在构造过程中采用了支配边界的概念进行Φ函数插入，而不是简单的通过joinset进行判断（注：基本块集合S的joinset即为在CFG中可以被S的两个或更多不同元素通过不相交路径到达的节点）。</li></ol>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SSA</tag>
      
      <tag>编译原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《SSA Book》- 2. SSA种类和特性</title>
    <link href="/2022/04/09/ssa-book-2/"/>
    <url>/2022/04/09/ssa-book-2/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="ssa-book--2.-ssa种类和特性">《SSA Book》- 2. SSA种类和特性</h1><p>本章首先介绍了SSA和non-SSA下的def-use链特性进行了分析。同时本章介绍了几种不同形式的SSA，包括最小SSA（MinimalSSA）、严格SSA（Strict SSA）、剪枝SSA（PrunedSSA）和常规和转换SSA（Conventional and transformed SSA）</p><h2 id="def-use与use-def链">Def-use与use-def链</h2><p>Def-use与use-def链并不是SSA特有的东西，非SSA形式下的每一个变量的所有def和use之间仍然存在def-use与use-def链。但是在非SSA形式中，由于存在多个def和use，需要用类似二维数组的形式，对变量所有的def和use之间的关系进行记录。然而，在SSA形式中每个变量只被def一次。因此每个变量仅需记录所有它的use，每一个use都对应了一条def-usechain，这样就可以用更为稀疏的形式对def-use关系进行存储。</p><p>SSA形式下的def-use与use-def链的优势可以总结为：</p><ol type="1"><li>数量相较non-SSA下普遍更少，并且更加便于数据存储；</li><li>更加方便数据流分析。SSA形式下的数据流分析只需要在def处保存数据流分析信息。在更新某一个def的数据流信息时，可以直接利用该条def所使用的变量对应的use-def链，获得存储在其他def处的数据流信息。</li></ol><h2 id="不同形式的ssa">不同形式的SSA</h2><p>在满足SSA定义“每个变量在程序中有且只有一个赋值语句”的前提下，Φ函数可以被插入到程序中不同的位置，因此同一个程序对应的SSA形式不是唯一的。通过增加更多约束，可以细分为不同SSA类型。</p><h3 id="最小ssaminimal-ssa">最小SSA（Minimal SSA）</h3><p>最小SSA指代的是“Φ函数数量最小的SSA形式”。构建SSA的过程包含两个阶段：放置Φ函数、变量重命名。在放置的过程中，为同一个原始变量两个不同定义到出口的所有路径交汇处添加Φ函数，既能构成具有Minimality特性的最小SSA形式。在下一章中展示的构造SSA方式即为构造最小SSA的方法。</p><blockquote><p>为什么这样生成就能得到Minimal SSA呢？（待补充）</p></blockquote><h3 id="严格ssastrict-ssa">严格SSA（Strict SSA）</h3><p>如果每个变量在从入口到出口的每条路径上，use之前都已被def，那么SSA是严格的。利用支配（dominate）的概念对其进行描述，若SSA中每个use被其def支配，那么称为严格SSA。下图展示了non-strict和strictSSA。相较图(a)中的SSA形式，图(b)中新添加了两个Φ函数。很明显，图(b)中的SSA并不是MinimalSSA。</p><figure><imgsrc="https://gqrelic-blog-data.oss-cn-shanghai.aliyuncs.com/ssa-book-2-2022-04-09-18-34-30.jpg"alt="non-strict SSA及其对应的strict SSA。⊥表示未定义的值" /><figcaption aria-hidden="true">non-strict SSA及其对应的strictSSA。⊥表示未定义的值</figcaption></figure><p>严格SSA带来的好处主要在特定算法中体现，包括：</p><ol type="1"><li>更好判断在一个点上，变量是否是活跃的（Live），可以应用于到达定值分析等；</li><li>测试两个变量是否相互干涉（interfere），可以用作图染色中，不需要另外显式构造变量间干涉图。</li></ol><h3 id="剪枝ssapruned-ssa">剪枝SSA（Pruned SSA）</h3><p>剪枝SSA是在最小SSA的基础上，添加约束“如果变量在基本块的入口处不是活跃的，就不必插入Φ函数”。以下图为例，图(a)是没有经过修剪的最小SSA形式，在经过了值编号（Valuenumbering）之后，Z1与Z2被认为是死变量，Z3与Y3具有相同的值。因此，关于Z3的Φ函数被删除，得到了图(b)中的剪枝SSA。</p><figure><imgsrc="https://gqrelic-blog-data.oss-cn-shanghai.aliyuncs.com/ssa-book-2-2022-04-09-22-07-40.png"alt="剪枝前后的SSA" /><figcaption aria-hidden="true">剪枝前后的SSA</figcaption></figure><p>可以发现，剪枝SSA的Φ函数数量可以小于最小SSA中的数量。这是因为最小SSA的minimality是指的是“不在生成的SSA上进行优化”前提下的Φ函数数量最小，而剪枝则对SSA本身进行了优化。</p><p>针对剪枝具体进行的阶段，书中给出了两种策略：</p><ol type="1"><li>先建立好最小SSA，然后进行死代码消除</li><li>在构造SSA的时候，对Φ函数进行活跃分析，删除不活跃的Φ函数</li></ol><p>第三章提出了半剪枝SSA（Semi-prunedSSA）。因为剪枝SSA需要进行活跃变量分析，有较高的代价，所以可以考虑先把最小SSA变成半剪枝SSA的形式。半剪枝SSA对只存在于单个基本块中的局部变量生成的Φ函数进行消除。这样，在进行活跃变量分析时，部分变量被消除，活跃分析代价变少。</p><blockquote><p>注：LLVM中使用Mem2reg构建SSA时，即为通过半剪枝SSA构造剪枝SSA的方法。</p></blockquote><h3 id="conventional-ssa和transformed-ssa">Conventional SSA和TransformedSSA</h3><p>如果两个变量的活动范围（Live-range）相交，它们就会相互干涉（interference）。从Φ函数出发，到所有Φ函数参数的定义连接起来，可以构成一个网络。当网络中的变量活跃范围互相不干涉时，则被称作传统（ConventionalSSA，C-SSA）。对C-SSA进行优化之后，可能会破坏这个性质，即被称作变形SSA（TransformedSSA，T-SSA）。</p><p>下图展示了同一个控制流图的不同状态。图(a)为原始控制流图，图(b)为添加Φ函数并且重命名之后的SSA。这个SSA是最小SSA，同时也是C-SSA。在C-SSA的基础上进行复制传播（copypropagation），即可得到图(c)。可以发现，Φ函数中两个变量的网络在第一个基本块上重合，因此为T-SSA。</p><figure><imgsrc="https://gqrelic-blog-data.oss-cn-shanghai.aliyuncs.com/ssa-book-2-2022-04-09-23-23-25.png"alt="复制传播将C-SSA转化成T-SSA" /><figcaption aria-hidden="true">复制传播将C-SSA转化成T-SSA</figcaption></figure><p>C-SSA形式在对SSA进行析构时（即将其转化为实际机器代码的过程）具有优势：C-SSA的析构过程是很简单的，直接将所有的定义和使用都被重命名以使用新变量，并且删除所有涉及这个等价类的Φ函数。以上图(b)为例，变量a2和a3被重命名为新的单独的变量，对应的Φ函数a4直接被删除。因此，在析构SSA过程中，首先要将T-SSA转化成C-SSA的形式。通常这个转化过程通过添加复制操作来完成。</p><p>其次，C-SSA形式更易于部分算法获得一些SSA的特性，这些特性在T-SSA中可能是难以被发现的。例如局部冗余消除（PRE）就利用了这些特性（第11章）。</p><p>除了以上两种情况，通常情况下都不会主动去维护SSA的Conventional性质。</p><h2id="关于干涉interference的进一步讨论">关于干涉（interference）的进一步讨论</h2><p>干涉概念的最终目的，是为了标明两个变量是否能通过同一个寄存器暂存。在之前的定义中，两个变量的live-range重叠，则认为两个变量是互相干涉的。这个对于干涉的定义实际上有些严苛了。实际上，可能存在“两个变量互相不干涉，但是他们live-range重叠”的情况。下面给出两个例子：</p><ol type="1"><li>如果两个变量在任何时间点都具有相同的值，那么他们之间是不干涉的；</li><li>可能两个变量的live-range在静态分析时是重叠的，但是可能会因为特殊的基本块跳转条件，导致实际执行时两个变量不会在同一时刻活跃，那么他们之间也是不干涉的。</li></ol><p>以上两个特例大多是可以通过静态分析过程发现的，这种优化后的干涉定义相较于简单且严苛的干涉定义，能使得部分算法取得更好的结果。</p>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SSA</tag>
      
      <tag>编译原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《SSA Book》- 1. 介绍</title>
    <link href="/2022/04/07/ssa-book-1/"/>
    <url>/2022/04/07/ssa-book-1/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="ssa-book--1.-介绍">《SSA Book》- 1. 介绍</h1><p>在知乎的编译优化相关书籍推荐中，看到了很多关于这本书的推荐，但是国内论坛关于这本书的讨论相对较少。《SSABook》从静态单赋值SSA的定义出发，讨论了构造、变换后重构、以及在SSA形式下不同编译算法的执行方式。此外，本书还介绍了很多高级SSA表示和用法，如果将来有时间，争取能对这部分进行补充。</p><h2 id="ssa的定义以及φ函数特性">SSA的定义以及Φ函数特性</h2><p>关于SSA的定义的文章遍地都是，就不在这里赘述了，只给出SSA的两个简单特性：</p><ol type="1"><li>每个变量在程序中有且只有一个赋值语句；</li><li>Φ函数将会被添加至控制流图中的控制流交汇点，用于聚合来自不同分支中的变量值。</li></ol><p>Φ函数的功能是很容易理解的，但是在计算机执行过程中，Φ函数究竟对应什么指令呢？书中针对这个问题进行了解答。Φ函数只存在于静态编译分析过程中，这些语句并不对应着目标硬件上某条指令。在SSA解构阶段，这些Φ函数将会被删除，并使用传统的复制操作对其进行序列化。此外，在部分SSAform中，同样存在部分扩展使得Φ函数存在对应的可执行指令，关于此部分将会在高级部分中进行讨论。</p><h2 id="ssa的优势">SSA的优势</h2><p>SSA最大优势来源于简化了数据流分析过程。传统数据流分析需要在每一个程序点处捕捉变量的信息，并利用格和流函数等概念，对这些程序点的信息值进行多次计算，得到不动点等信息。这使得在程序中每个程序点，都需要记录此处在数据流分析过程中信息的值，并在每一次运算过程中计算所有的值，即使在这些程序点中大部分信息没有改变。</p><p>然而，SSA形式下的数据流分析可以基于每个变量的def-use链进行分析。分析过程只需要记录每个变量定义处的信息，并通过def-use链更新信息。这大大减少了数据流分析的复杂度。这也使得程序员能够更加容易地编写数据流分析算法，调试难度更低。</p><p>下图中展示了传统形式和SSA形式下对于程序中x与y两个变量的零值传播分析对比。图(a)中在每个基本块的入口和出口处均设置了信息槽，用于记录当前位置x和y变量的值是否为0。可以看出，在大多数与两个变量无关的基本块处，入口和出口的信息是没有变化的，这造成了一定的浪费。</p><p>图(b)中展示了基于SSA形式下的数据流分析过程，可以发现，只需要在每个基本块的结尾设置与该基本块中定义的变量相关的信息槽，即可完成对整个控制流图的数据分析。在SSA形式下，需要的信息槽数量明显减少，数据流分析的效率可以得到提升。</p><figure><imgsrc="https://gqrelic-blog-data.oss-cn-shanghai.aliyuncs.com/ssa-book-1-2022-04-08-09-55-37.jpg"alt="使用SSA分析的控制流图示例" /><figcaption aria-hidden="true">使用SSA分析的控制流图示例</figcaption></figure><h2 id="关于ssa存在的谬论">关于SSA存在的谬论</h2><p>一部分人认为SSA可能存在一部分缺点，然而实际上针对这些缺点已经有了很好的解决方法。本书将会在后续部分中对这些可能存在的进行研究和解释。此处先给出部分SSA可能存在的缺点，以及对这些缺点进行讨论的章节：</p><table><thead><tr class="header"><th>SSA可能存在的缺点</th><th>解决策略</th></tr></thead><tbody><tr class="odd"><td>SSA增加了变量的数量</td><td>第2章展示了减少变量数量的优化方法</td></tr><tr class="even"><td>SSA难以维护</td><td>第3和5章展示了编译优化过程中对SSA结构的高效维护策略</td></tr><tr class="odd"><td>SSA析构时将带来大量复制操作</td><td>第3和21章展示了高效的SSA析构策略</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SSA</tag>
      
      <tag>编译原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
