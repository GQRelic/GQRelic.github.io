<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>《SSA Book》- 2. SSA种类和特性</title>
    <link href="/2022/04/09/ssa-book-2/"/>
    <url>/2022/04/09/ssa-book-2/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="ssa-book--2.-ssa种类和特性">《SSA Book》- 2. SSA种类和特性</h1><p>本章首先介绍了SSA和non-SSA下的def-use链特性进行了分析。同时本章介绍了几种不同形式的SSA，包括最小SSA（MinimalSSA）、严格SSA（Strict SSA）、剪枝SSA（PrunedSSA）和常规和转换SSA（Conventional and transformed SSA）</p><h2 id="def-use与use-def链">Def-use与use-def链</h2><p>Def-use与use-def链并不是SSA特有的东西，非SSA形式下的每一个变量的所有def和use之间仍然存在def-use与use-def链。但是在非SSA形式中，由于存在多个def和use，需要用类似二维数组的形式，对变量所有的def和use之间的关系进行记录。然而，在SSA形式中每个变量只被def一次。因此每个变量仅需记录所有它的use，每一个use都对应了一条def-usechain，这样就可以用更为稀疏的形式对def-use关系进行存储。</p><p>SSA形式下的def-use与use-def链的优势可以总结为：</p><ol type="1"><li>数量相较non-SSA下普遍更少，并且更加便于数据存储；</li><li>更加方便数据流分析。SSA形式下的数据流分析只需要在def处保存数据流分析信息。在更新某一个def的数据流信息时，可以直接利用该条def所使用的变量对应的use-def链，获得存储在其他def处的数据流信息。</li></ol><h2 id="不同形式的ssa">不同形式的SSA</h2><p>在满足SSA定义“每个变量在程序中有且只有一个赋值语句”的前提下，Φ函数可以被插入到程序中不同的位置，因此同一个程序对应的SSA形式不是唯一的。通过增加更多约束，可以细分为不同SSA类型。</p><h3 id="最小ssaminimal-ssa">最小SSA（Minimal SSA）</h3><p>最小SSA指代的是“Φ函数数量最小的SSA形式”。构建SSA的过程包含两个阶段：放置Φ函数、变量重命名。在放置的过程中，为同一个原始变量两个不同定义到出口的所有路径交汇处添加Φ函数，既能构成具有Minimality特性的最小SSA形式。在下一章中展示的构造SSA方式即为构造最小SSA的方法。</p><blockquote><p>为什么这样生成就能得到Minimal SSA呢？（待补充）</p></blockquote><h3 id="严格ssastrict-ssa">严格SSA（Strict SSA）</h3><p>如果每个变量在从入口到出口的每条路径上，use之前都已被def，那么SSA是严格的。利用支配（dominate）的概念对其进行描述，若SSA中每个use被其def支配，那么称为严格SSA。下图展示了non-strict和strictSSA。相较图(a)中的SSA形式，图(b)中新添加了两个Φ函数。很明显，图(b)中的SSA并不是MinimalSSA。</p><figure><imgsrc="https://gqrelic-blog-data.oss-cn-shanghai.aliyuncs.com/ssa-book-2-2022-04-09-18-34-30.jpg"alt="non-strict SSA及其对应的strict SSA。⊥表示未定义的值" /><figcaption aria-hidden="true">non-strict SSA及其对应的strictSSA。⊥表示未定义的值</figcaption></figure><p>严格SSA带来的好处主要在特定算法中体现，包括：</p><ol type="1"><li>更好判断在一个点上，变量是否是活跃的（Live），可以应用于到达定值分析等；</li><li>测试两个变量是否相互干涉（interfere），可以用作图染色中，不需要另外显式构造变量间干涉图。</li></ol><h3 id="剪枝ssapruned-ssa">剪枝SSA（Pruned SSA）</h3><p>剪枝SSA是在最小SSA的基础上，添加约束“如果变量在基本块的入口处不是活跃的，就不必插入Φ函数”。以下图为例，图(a)是没有经过修剪的最小SSA形式，在经过了值编号（Valuenumbering）之后，Z1与Z2被认为是死变量，Z3与Y3具有相同的值。因此，关于Z3的Φ函数被删除，得到了图(b)中的剪枝SSA。</p><figure><imgsrc="https://gqrelic-blog-data.oss-cn-shanghai.aliyuncs.com/ssa-book-2-2022-04-09-22-07-40.png"alt="剪枝前后的SSA" /><figcaption aria-hidden="true">剪枝前后的SSA</figcaption></figure><p>可以发现，剪枝SSA的Φ函数数量可以小于最小SSA中的数量。这是因为最小SSA的minimality是指的是“不在生成的SSA上进行优化”前提下的Φ函数数量最小，而剪枝则对SSA本身进行了优化。</p><p>针对剪枝具体进行的阶段，书中给出了两种策略：</p><ol type="1"><li>先建立好最小SSA，然后进行死代码消除</li><li>在构造SSA的时候，对Φ函数进行活跃分析，删除不活跃的Φ函数</li></ol><p>第三章提出了半剪枝SSA（Semi-prunedSSA）。因为剪枝SSA需要进行活跃变量分析，有较高的代价，所以可以考虑先把最小SSA变成半剪枝SSA的形式。半剪枝SSA对只存在于单个基本块中的局部变量生成的Φ函数进行消除。这样，在进行活跃变量分析时，部分变量被消除，活跃分析代价变少。</p><blockquote><p>注：LLVM中使用Mem2reg构建SSA时，即为通过半剪枝SSA构造剪枝SSA的方法。</p></blockquote><h3 id="conventional-ssa和transformed-ssa">Conventional SSA和TransformedSSA</h3><p>如果两个变量的活动范围（Live-range）相交，它们就会相互干涉（interference）。从Φ函数出发，到所有Φ函数参数的定义连接起来，可以构成一个网络。当网络中的变量活跃范围互相不干涉时，则被称作传统（ConventionalSSA，C-SSA）。对C-SSA进行优化之后，可能会破坏这个性质，即被称作变形SSA（TransformedSSA，T-SSA）。</p><p>下图展示了同一个控制流图的不同状态。图(a)为原始控制流图，图(b)为添加Φ函数并且重命名之后的SSA。这个SSA是最小SSA，同时也是C-SSA。在C-SSA的基础上进行复制传播（copypropagation），即可得到图(c)。可以发现，Φ函数中两个变量的网络在第一个基本块上重合，因此为T-SSA。</p><figure><imgsrc="https://gqrelic-blog-data.oss-cn-shanghai.aliyuncs.com/ssa-book-2-2022-04-09-23-23-25.png"alt="复制传播将C-SSA转化成T-SSA" /><figcaption aria-hidden="true">复制传播将C-SSA转化成T-SSA</figcaption></figure><p>C-SSA形式在对SSA进行析构时（即将其转化为实际机器代码的过程）具有优势：C-SSA的析构过程是很简单的，直接将所有的定义和使用都被重命名以使用新变量，并且删除所有涉及这个等价类的Φ函数。以上图(b)为例，变量a2和a3被重命名为新的单独的变量，对应的Φ函数a4直接被删除。因此，在析构SSA过程中，首先要将T-SSA转化成C-SSA的形式。通常这个转化过程通过添加复制操作来完成。</p><p>其次，C-SSA形式更易于部分算法获得一些SSA的特性，这些特性在T-SSA中可能是难以被发现的。例如局部冗余消除（PRE）就利用了这些特性（第11章）。</p><p>除了以上两种情况，通常情况下都不会主动去维护SSA的Conventional性质。</p><h2id="关于干涉interference的进一步讨论">关于干涉（interference）的进一步讨论</h2><p>干涉概念的最终目的，是为了标明两个变量是否能通过同一个寄存器暂存。在之前的定义中，两个变量的live-range重叠，则认为两个变量是互相干涉的。这个对于干涉的定义实际上有些严苛了。实际上，可能存在“两个变量互相不干涉，但是他们live-range重叠”的情况。下面给出两个例子：</p><ol type="1"><li>如果两个变量在任何时间点都具有相同的值，那么他们之间是不干涉的；</li><li>可能两个变量的live-range在静态分析时是重叠的，但是可能会因为特殊的基本块跳转条件，导致实际执行时两个变量不会在同一时刻活跃，那么他们之间也是不干涉的。</li></ol><p>以上两个特例大多是可以通过静态分析过程发现的，这种优化后的干涉定义相较于简单且严苛的干涉定义，能使得部分算法取得更好的结果。</p>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SSA</tag>
      
      <tag>编译原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《SSA Book》- 1. 介绍</title>
    <link href="/2022/04/07/ssa-book-1/"/>
    <url>/2022/04/07/ssa-book-1/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="ssa-book--1.-介绍">《SSA Book》- 1. 介绍</h1><p>在知乎的编译优化相关书籍推荐中，看到了很多关于这本书的推荐，但是国内论坛关于这本书的讨论相对较少。《SSABook》从静态单赋值SSA的定义出发，讨论了构造、变换后重构、以及在SSA形式下不同编译算法的执行方式。此外，本书还介绍了很多高级SSA表示和用法，如果将来有时间，争取能对这部分进行补充。</p><h2 id="ssa的定义以及φ函数特性">SSA的定义以及Φ函数特性</h2><p>关于SSA的定义的文章遍地都是，就不在这里赘述了，只给出SSA的两个简单特性：</p><ol type="1"><li>每个变量在程序中有且只有一个赋值语句；</li><li>Φ函数将会被添加至控制流图中的控制流交汇点，用于聚合来自不同分支中的变量值。</li></ol><p>Φ函数的功能是很容易理解的，但是在计算机执行过程中，Φ函数究竟对应什么指令呢？书中针对这个问题进行了解答。Φ函数只存在于静态编译分析过程中，这些语句并不对应着目标硬件上某条指令。在SSA解构阶段，这些Φ函数将会被删除，并使用传统的复制操作对其进行序列化。此外，在部分SSAform中，同样存在部分扩展使得Φ函数存在对应的可执行指令，关于此部分将会在高级部分中进行讨论。</p><h2 id="ssa的优势">SSA的优势</h2><p>SSA最大优势来源于简化了数据流分析过程。传统数据流分析需要在每一个程序点处捕捉变量的信息，并利用格和流函数等概念，对这些程序点的信息值进行多次计算，得到不动点等信息。这使得在程序中每个程序点，都需要记录此处在数据流分析过程中信息的值，并在每一次运算过程中计算所有的值，即使在这些程序点中大部分信息没有改变。</p><p>然而，SSA形式下的数据流分析可以基于每个变量的def-use链进行分析。分析过程只需要记录每个变量定义处的信息，并通过def-use链更新信息。这大大减少了数据流分析的复杂度。这也使得程序员能够更加容易地编写数据流分析算法，调试难度更低。</p><p>下图中展示了传统形式和SSA形式下对于程序中x与y两个变量的零值传播分析对比。图(a)中在每个基本块的入口和出口处均设置了信息槽，用于记录当前位置x和y变量的值是否为0。可以看出，在大多数与两个变量无关的基本块处，入口和出口的信息是没有变化的，这造成了一定的浪费。</p><p>图(b)中展示了基于SSA形式下的数据流分析过程，可以发现，只需要在每个基本块的结尾设置与该基本块中定义的变量相关的信息槽，即可完成对整个控制流图的数据分析。在SSA形式下，需要的信息槽数量明显减少，数据流分析的效率可以得到提升。</p><figure><imgsrc="https://gqrelic-blog-data.oss-cn-shanghai.aliyuncs.com/ssa-book-1-2022-04-08-09-55-37.jpg"alt="使用SSA分析的控制流图示例" /><figcaption aria-hidden="true">使用SSA分析的控制流图示例</figcaption></figure><h2 id="关于ssa存在的谬论">关于SSA存在的谬论</h2><p>一部分人认为SSA可能存在一部分缺点，然而实际上针对这些缺点已经有了很好的解决方法。本书将会在后续部分中对这些可能存在的进行研究和解释。此处先给出部分SSA可能存在的缺点，以及对这些缺点进行讨论的章节：</p><table><thead><tr class="header"><th>SSA可能存在的缺点</th><th>解决策略</th></tr></thead><tbody><tr class="odd"><td>SSA增加了变量的数量</td><td>第2章展示了减少变量数量的优化方法</td></tr><tr class="even"><td>SSA难以维护</td><td>第3和5章展示了编译优化过程中对SSA结构的高效维护策略</td></tr><tr class="odd"><td>SSA析构时将带来大量复制操作</td><td>第3和21章展示了高效的SSA析构策略</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SSA</tag>
      
      <tag>编译原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
